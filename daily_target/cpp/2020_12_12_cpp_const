使用const 限定对象的值不能被改变 也称为常量
全局变量 存储在程序的全局区
静态变量存储在静态区域
局部变量存储在栈区
动态内存(new/malloc)出来的内存区域在堆区

初始化和const
因为const对象一旦创建以后就不能再改变，所以const必须初始化
但是用一个对象去初始化另外一个对象的时候 该对象是不是const 都无所谓

但是一个非const的引用指向一个const对象时就会报错

默认状态下 const 对象仅在该文件中有效如果多个文件中声明了相同的const对象 则不会冲突 不会像全局变量一样重新定义
所以如果想在其他文件中引用这个全局的const 对象 则需要加extern声明 类似全局变量
extern 还可以放在变量定义的前面

初始化和对const对象的引用
1. 引用的类型 必须与其所引用的对象类型一直
---------------以下是两种例外情况-------------
2. 初始化常量的引用时允许任意表达式作为初始值，只要该表达式的结果能够转换成引用的类型即可 所以允许为一个常量引用绑定非常量的对象，字面值，甚至时一个表达式
const double dv = 4.8;
const int& i = dv;
上面的代码会被编译器转换成
const int temp = dv;
const int& i = temp; //这个就是cpp臭名昭著的临时对象的问题 因为编译器需要一个临时变量来缓存表达式的结果
如果是非const表达式
int& i = dv; //则会编译报错 因为引用到一个临时对象 就算可以改变也没多大意义 所以cpp认为是一个非法的行为

指针和const
要想取得常量的地址就必须得使用常量的指针
常量指针 仅仅是要求不能通过该指针改变对象的值 而没有规定对象是否是常量,常量指针必须初始化就跟引用和常量引用一样必须初始化，并且一旦初始化以后它所指向的内容就不能再改变了

类型名* const 说明不能通过它改变它指向的内容
const 类型名* 不能改变它的指向

    int a = 1;
 48     /*                     
 49     const int* p = &a; //不能修改它指定内存区域的内容
 50     p = NULL; 编译报错 error: assignment of read-only location ‘p’
 51     */
 52     const int* p = &a;
 53     *p = 2; 编译报错 error: assignment of read-only location ‘* p’
 54     //p = &b; 全局环境下 这行代码会报p 未被定义 所以全局环境只适合定义和声明
