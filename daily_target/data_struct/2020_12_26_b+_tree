数据库相关b树
首先b树的存在 解决 大量i/o问题 被广泛用于数据库
b+树的规则
1. 每个结点x有如下属性
  a x.n 当前存储在结点x中的关键字个数
  b x.n 关键字本身x.key1 x.key2....x.keyn以非降序存放x中关键为(1,2,3,4,5,6)这种顺序存放
  c x.leaf 一个bool值 如果x是叶节点 则为true 如果x是内部结点则为false
2. 每个结点x还包含x.n+1个指向其孩子的指针x.c1 x.c2...x.cn+1 叶结点没有孩子
3. x.key对存储在各子树中的关键字进行分割 保证 c1结点中的值小于k1 c2节点中的值大于k1小于k2
x 结点 关键字       3       5
            c1(1,2)  c2(4)    c3(6,7,8)
   意思就是关键字A的左边的子结点的关键字都小于关键字 关键字右边的子结点中的关键字大于等于关键字A
4. 每个叶子结点具有相同的深度,即树的高度h(这是避免多i/o问题,因为没读取一次子结点就要进行一次i/o)
5 每个结点的关键字个数有上限和下限。用一个被称为b树的最小度数(minnum degree)的固定整数t>=2来表示这些界
  a 除了根结点以外的每个结点必须至少有t-1个关键字。因此除了根结点以外的每个内部结点至少有t个孩子(这是根据规则2 每个结点包含n+1个指向其孩子的指针) 如果树非空,根结点至少有一个关键字子
  b 每个结点至多包含2t-1个关键字,因此一个内部结点至多可以有2t个孩子。当一个结点恰好有2t-1个关键字时。该结点称为满的
  
 b+树的插入操作
  首先根据要插入的关键字 找到合适的插入位置(叶子结点)
    如果该叶子结点已经满了
      则将该叶子结点根据t分裂成两个各含t-1个关键字的子结点,中间关键字t提升到父结点,如果父结点也是满的，就必须在插入新关键字之前进行分裂，一直按照这个流程向上分裂,直到满足条件为止 递归?
    叶子结点非满
      直接安插在叶子结点合适的位置
    但是实际上采用的是在新插入结点往下找合适位置的同时遇到了满结点(包括叶结点本身)就进行分裂,这样当要分裂一个满的结点时 可以保证他的父结点不是满的，然后直接插入就行
 b+树的删除操作
   删除的原则 必须要保证 因为删除了结点中的一个关键字过后变得太小 在删除过程中要保证x中的关键字个数为最小度数t
   1. 如果关键字k在结点x中,并且x是叶结点,则从x中删除k(叶子结点中的关键字直接删除)
   2. 如果关键字k在结点x中,并且x是内部结点,则做以下操作
    a. 如果结点x中前于关键字k的子结点y至少包含t个关键字,则找出k在y结点中的前驱关键字k` 然后删除y结点中的k` 并用k`替换掉x结点中的k
               5    8     11      结点x
      |1 2 3 4| 6 7| 9 10|  12 13
     删除结点x中的关键字8 因为前驱结点y |6 7| 中8的前驱关键字k`为7 所以删除后的样子就是
               5    7     11      结点x
      |1 2 3 4| 6 |  9 10|  12 13
    b. 对称的,如果y有少于t个关键字,则检查结点x中后于关键字k的子结点z 如果z至少有t个关键字,则找出k在z结点中后继结点k` 然后删除k`并且用k`替换x中的结点k
               5    7     11      结点x
      |1 2 3 4| 6 |  9 10|  12 13
      次数t = 2 删除x结点中的7 结果如下
               5    9     11      结点x
      |1 2 3 4| 6 |  10|    12 13
      此时结点|6|和结点|10|可以进行一次合并
    c. 否则 如果y z都只含有t-1个关键字,则将关键字k和结点z都合并进结点y 然后释放z并从y中删除k
               5    9     11      结点x
      |1 2 3 4|  6 |  10|    12 13
                y    z
      删除x结点中9并且进行y结点过后就是这个样子的
               5      11      结点x
      |1 2 3 4|  6 10|    12 13
                y
   3. 如果关键字k不在当前内部结点x上，则确定必包含k的子树的根x.c1 如果x.c1只包含t-1个关键字，必须通过步骤3a和3b来将至一个至少包含t个关键字的结点。然后通过对x的某个合适的子结点进行递归而结束
