首先索引模型
1. hash索引 
  底层hash表 底层依赖于一个数组 把key通过hash函数转换成对应的index 然后对应Index上存放该数据
  优点:查询较快
    这个优点还是在hash表中数据较少的情况 随着数据增多冲突因子的变大 一般会产生hash冲突 这个时候可以采用 修改hash函数或者是增大内存(内存允许的情况下)来降低冲突因子
    如果修改hash函数和增大内存不好实现的话 就只有将hash里面修改为存储链表的形式 对于通过hash产生同一个关键字的数据则直接挂载到链表尾部， 如果某一列的链表长度过程 则还是说明hash函数有问题
    最后实在不行就只有在hash里面挂载一颗红黑树或者平衡二叉树，其实这个还不如直接用红黑树和平衡二叉树了
  缺点不支持范围查询 如果要查找一个范围内的数据只有把整个hash表遍历一遍
  所以比较适合等值查询
2. 数组索引
  优点 内存连续 支持随机访问 所以能够快速的定位和范围查询
  缺点 新增或作者删除时候操作比较麻烦 所以不适合更新频繁的数据
  比较适合等值查询和范围查询
3. 平衡二叉树和红黑树
  优点 因为都是二叉搜索树 所以支持等值查询和范围查询 也支持快速动态更新
  缺点 对于像数据库这种海量数据 构建一个平衡二叉树和红黑树的话 树的高度过高 磁盘i/o次数过多
所以数据库一般都采用b树系列作为数据库底层数据模型
InnoDB大概是的b+树索引 大概是1200个结点 当这棵树高为4的时候就可以存储1200的3次方个数据 所以查找一个值最多只需要三次磁盘i/o 因为根节点在内存中
其实跳表和b+树等很相似反而实现起来还更简单 还有LSM树

---------------------------------------------------------索引实战---------------------------------------------------------------------
1. 索引是在引擎层面实现的
  所以并没有统一的索引标准，即不同的存储引擎索引的工作方式可能不一样
2. InnoDB的索引模型
  每一种索引在InnoDB里面对应一颗b+树
  主键索引:
    主键索引的叶子结点存的是整行数据。在InnoDB里主键索引页被称为聚簇索引(clusterd index)
      索引层都是主键上的数据
  非主键索引
    非主键索引的叶子结点内容是主键的值。在InnoDB里面非主键索引页被称为二级索引(secondary index)
  
  主键索引和非主键索引的查询区别
    主键索引查询
      select * from T where ID=500 这个语句则只会搜索主键索引这颗b+树
    非主键索引查询
      select * from T where k = 5这个索引搜选要查询以k为索引的b+树 查找到对应的主键过后 再从主键索引b+树中 找对应的数据
    所以从上面的流程可以得知 虽然索引使用起来很方便 但是维护起来很麻烦 当数据更新以后对应的索引也需要更新
 索引的维护
  如果往后追加数据那还比较方便
    比如1 2 3 5 6这几个数据在数据库中 如果新插入一个7 则直接在6后面追加就行了
    但是如果是插入一个4 则需要3 5之间空出位置进行插入 而且根据b+树的规则 如果插入结点的关键字达到了最大值还要进行分裂 提取关键字到父结点中 如果父结点也满了 继续向上分裂
 
 关于自增主键的分析
  什么样的场景需要自增主键?
    每次插入一条新记录,都是追加操作,都不涉及到挪动其他记录，也不会触发叶子结点的分裂
    而业务逻辑字段做主键 则往往不容易保证有序插入，这样写数据的成本较高
    
  主键索引选择参考点
  1. 主键长度越长 普通索引(非主键索引的叶子结点越长),普通索引占用的空间也就越小(所以从性能和存储空间方面考虑,自增主键往往是更合理的选择)
  2. 如果该表只有一个索引,就适合拿来做主键!
  
  索引的创建方式:
  1. create index 索引名 on 表名(列名)
    示例代码
    mysql> create index name_index on T(name);
    Query OK, 0 rows affected (0.03 sec)
    Records: 0  Duplicates: 0  Warnings: 0
    
  2. alter table 表名 add index 索引名(列名)
    mysql> alter table T add index name_index(name);
    Query OK, 0 rows affected (0.06 sec)
    Records: 0  Duplicates: 0  Warnings: 0
  
  3. 创建表的时候直接指定
    CREATE TABLE mytable(  
 
      ID INT NOT NULL,   
 
      username VARCHAR(16) NOT NULL,  
 
      INDEX [indexName] (username(length))   //指定username前面length个字符作为索引
 
);  
  索引的删除方式
    alter table 表名 drop index 索引名
    mysql> alter table T drop index name_index;
    Query OK, 0 rows affected (0.02 sec)
    Records: 0  Duplicates: 0  Warnings: 0
  
