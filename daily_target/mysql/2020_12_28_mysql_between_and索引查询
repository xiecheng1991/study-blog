
如果创建如下表

mysql> create table T (
2 ID int primary key,
3 k int NOT NULL DEFAULT 0, 
4 s varchar(16) NOT NULL DEFAULT '',
5 index k(k))
6 engine=InnoDB;
78 insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(7

这个表一共有两个索引
根据主键ID创建的主键索引 和根据k 创建的非主键索引(k树索引，每个结点的关键字存储的是主键)

如果执行between and语句查询流程
select * from T where k between 3 and 5 那么执行流程为

1. 先从k树索引上找到k=3的记录,取得ID等于300
2. 再到ID树上找对应ID=300的数据
3. 在k树索引取下一个值k=5,取得ID=500
4. 再回到ID树上查找到ID=500的数据
5. 在k树索引取下一个值K=6不满足条件，循环结束

1 3 5这种从非主键索引回到主键索引的过程就叫作回表，这中间的过程就会产生浪费 从一棵树又到另外一棵树再执行查找的过程
如果执行的是 select ID from T where k between 3 and 5,这时只需要查询ID的值,而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说在这个查询里面，索引k已经覆盖了我们的查询需求
我们称之为覆盖索引 其实就是通过这个索引就可以完成我们的查询需求，我们就把这个索引称之为覆盖索引

由于覆盖索引可以减少树的搜索次数，显著的提升查询性能，所以使用覆盖索引是一个常用的性能优化手段

联合索引:
  也被称为复合索引
  加入有下面语句
  select * from users where area = 'beijing' and age = 22;
  复合索引就是针对area和age两列创建一个索引,创建了这个索引之后就相当于创建了(area,age)和(area)两个单独的索引，并且这被称为最佳左前缀特性
  因此我们在创建复合索引时应该将最常用的限制条件列放在最左边，依次递减
  但是如果说 select * from users where age = 22; 则无法使用(area,age)这个索引 必须要维护一个age索引 才能提高查询效率  这就是最左前缀匹配原则
  
  索引不会包含有NULL值的列
  只要列中包含有NULL值都将不会包含进索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的 因为放一个NULL值进索引没有多大意义,所以在设计数据库时不要让想要成为
  索引的列成为NULL
  
  如果既有联合查询 又有基于a,b各自的查询!
  查询条件里面只有b的语句，是无法使用a,b这个联合索引 反而根据mysql的优化去走b索引


