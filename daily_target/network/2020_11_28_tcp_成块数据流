在讲成块数据流之前又先补充了 tcp延时确认机制的另一种处理情况
cli                                                 svr
4 ---------PSH 1:1025(1024) ack1, win 4096------->
5 ---------PSH 1025:2049(1024) ack1, win 4096---->
6 ---------PSH 2049:3073(1024) ack1, win 4096---->
7 <--------ack 2049, win 4096---------------------
8 <--------ack 3073, win 4096---------------------
9 ---------PSH 3073:4097(1024) ack1, win 4096
10<--------ack 4097,win 4096----------------------

cli端先发送了(4-6)三个报文 报文大小为1024字节
svr先收到报文4 然后标记为延时确认 然后又收到5 则立即回复一个ack,所以这里延时确认的另一个处理方式就是 如果在一个延时确认期间又收到了一个报文则立即回复最新报文的ack 7
说明通常是采用的隔一个报文确认机制 收到的第一个报文标记为延时确认 在超时之前收到了第二个报文 则立即回复第二个报文的ack 如果超时 则回复第一个报文的ack
 报文8和报文10 则是超过了延时确认的延时时长所以回复了ack
所以使用滑动窗口协议时,接收方不必确认每一个收到的分组..在tcp中ack是累积的，他们表示接收方已经正确的收到了直到确认序号减1的所有字节

窗口更新
如果上一条报文过后导致接收端窗口大小已满,则会发送一个ack,通过窗口大小为0，表示接收方不能再接收更多的数据了

当可以接收数据过后会发送另外一个ack 通告窗口的大小,但是他不确认任何数据
如下例子
cli                                                      svr
4  ---------->PSH 1:1025(1024) ack 1, win 4096---------->
5  ---------->PSH 1025:2049(1024) ack 1, win 4096------->
6  ---------->PSH 2049:3073(1024) ack 1, win 4096------->
7  ---------->PSH 3073:4096(1024) ack 1, win 4096------->
   <---------ack 4097,win 0 ----------------------------- 8 回复ack, 并且告诉对端 我的接收区窗口大小已满
   <---------ack 4097, win 4096 ------------------------- 9 再发送一个ack 通告我的接收区窗口打小为4096 又可以接收4096个字节的数据了 这个就称为窗口通告
   
滑动窗口
   当滑动窗口的左边沿和右边沿重合时 此时称为0窗口，此时发送方不能够发送任何数据
   
   本机能发送数据的滑动窗口大小就是对方的接收缓冲区大小 所以如果此时本机的滑动窗口大小为0 也即0窗口 则表明对方发送缓冲区已满
   所以会定时发送一个窗口探测报文
   
   如果此时 关闭了发送端则会立即产生一个rst报文给接收端
