当我们收到一个失序的报文时,tcp立即需要产生一个ACK(一个重复的ACK),这个重复的ACK不应该被延迟，该重复的ACK的目的是为了让对方收到一个失序的报文段，并告诉对方做自己希望收到的序号
为什么要等待少量重复的ACK到来
  由于我们不知道一个重复的ACK是由一个丢失的报文段引起的 还是由于仅仅出现了几个报文段的重新排序，因此我们等待少量重复的ACK到来
  如果是因为重新排序，则在重新排序时产生的ACK最多重复1到2两次 但是如果重复3个或3个以上的重复ACK，就非常可能是一个报文段丢失了，于是我们就需要重传丢失的数据报文段，而无需等待超时定时器的溢出
  这就是快速重传算法
接下来执行的不是慢启动算法而是拥塞避免算法 这就是快速恢复算法

如何决定执行慢启动还是拥塞控制呢？
  如果收到重复的ACK说明某个报文段已经丢失了 由于接收方只有在接收到了 另一个不是自己期望的报文段时 才会产生重复的ACK，也就是说在收发两端之间仍然有流动的数据，所以不执行慢启动来突然减少数据流
  
 拥塞避免算法的实现
  1) 当收到三个重复的ACK时，将ssthresh设置为当前拥塞窗口cwnd的一半。将重传丢失的报文段。设置cwnd为ssthresh加上三倍的报文段大小.
  2) 每次收到另一个重复的ACK时,cwnd增加一个报文段大小并发送一个分组 （如果新的cwnd允许发送）
  3）当一个确认新数据的ACK到达时,设置cwnd为ssthresh(第一步中设置的值)，这个ACK不仅包含对重传的确认还包含确认丢失报文段之间收到的报文段的确认，这一步就是拥塞避免，因为当分组丢失时 我们将当前的速率减半
  
拥塞避免的例子
序号        发送                接收             注释             cwnd          ssthresh
58                           ACK 6657       新的数据确认          2426          512
59       8705:8961(256)      
60                           ACK 6657       重复ACK #1           2426          512
61                           ACK 6657       重复ACK #2           2426          512
62                           ACK 6657       重复ACK #3           1792          1024 当收到第三个重复的ACK的时候ssthresh 被设置为cwnd的一半(四舍五入到报文段的下一个倍数),而cwnd被设置为ssthresh
                                                                                    加上重复的ACK数乘以报文段大小(也即1024加上3倍的256)然后重传数据
                                                                                    
                                                                                    
 ----------------未完待续 因为看得头昏脑胀了 所以想休息几分钟 然后看看其他的东西-------------------------------------------                                                                       
