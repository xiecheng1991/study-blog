listen函数主要做两件事
1. 当socket创建一个套接字时，它被假设为一个主动套接字,也就是说它是一个将调用connect发起连接的套接字。listen函数把一个未连接的套接字转换成被动套接字
  根据tcp状态图调用listen导致套接字从closed状态转换成了listen状态
2. 本函数的第二个参数(backlog)规定了内核应该为相应套接字排队的最大连接个数(tcp层面也维护了一个连接队列,这个队列是tcp连接三次握手完成但是还未被应用程序处理)

linux下使用netstat -n -l  -l显示监听套接字 -n显示ip地址而不是需要dns解析的名字
服务器代码listen到8888端口
    if ( listen( listen_fd, MAX_LEN ) ) {
 61         printf( "listen error:%d\n", errno );
 62         return -1;
 63  }

root@instance-u1n6fu49:~# netstat -n -l
tcp        0      0 0.0.0.0:8888            0.0.0.0:*               LISTEN 

backlog参数的理解
内核为任何一个监听套接字维护两个队列
1.未完成连接队列
  服务器这边正存在等待tcp三次握手过程中的套接字(即syn_recv状态的套接字)就处于未完成连接队列中
2.已完成连接队列
  主要存放已经完成了tcp三次握手的套接字(即处于established状态的套接字)
客户                            服务器
connect调用  syn j ---->    在未完成队列建立条目
              <----- syn k ack j + 1
connect返回  ack k + 1 ------->  该条目从未完成队列转移至已完成队列,accept接收返回
所以只有当在未完成队列当中的条目 三次握手完成或者是超时才会从未完成队列移除
当三次握手完成以后 就把该项从未完成队列建立条目中移动到连接队列的队尾,当应用程序调用accept时,已完成队列当中的头项将返回给进程,如果队列为空进程将被投入睡眠,直到tcp在该队列当中放入一项才将其唤醒

