非阻塞i/o和多路复用
1. 非阻塞i/o
  非阻塞i/o使我们可以发出open,read,write这样的i/o操作，并使这些操作永远不会阻塞，如果这种操作不能完成，则立即调用出错返回,表示如果该操作继续执行将阻塞
  对于一个给定的描述符,有两种将其指定为非阻塞i/o的方法
  1) 如果调用open获得描述符， 则可指定o_nonblock标志
  2）对于一个已经打开的描述符，则可调用fcntl,由该函数打开o_nonblock标志
  对于一个非阻塞的描述符如果无数据可读,则read返回-1,errno设置为EAGAIN
  
1 #include<unistd.h>                                                                              
  2 #include<stdio.h>
  3 #include<stdlib.h>                                                                              
  4 #include<fcntl.h>                                                                               
  5 #include<errno.h>
  6 #include<string.h>                                                                              
  7 
  8 int
  9 main( int argc, char* argv ) {                                                                  
 10     char buf[1024] = {'0'};                                                                     
 11     
 12     //测试例子
 13     //stdin本来是阻塞的读取 设置为非阻塞并且在没有数据读的时候返回出错,因为在套接字中返回字符'0',
 14     //就不能判断到底是套接字断开连接还是没有数据可读                                            
 15     //所以返回-1 并且将errno 设置为EAGAIN或者EWOULDBLOCK                                        
 16     int fd = 0;                                                                                 
 17     fcntl( fd, F_SETFL, O_NONBLOCK ); //set nonblock                                            
 18     while( 1 ) {                                                                                
 19         sleep( 1 );                                                                             
 20         memset( buf, '0', sizeof( buf ) );                                                      
 21         int ntowrite = read( fd, buf, sizeof( buf ) );                                          
 22         if ( ntowrite < 0 ) {                                                                   
 23             printf( "read error:%d\t%s\n", errno, strerror( errno ) );                          
 24             continue;                                                                           
 25         }                                                                                       
 26         printf( "read :%s\n", buf );                                                            
 27     }                                                                                           
 28     return 0;                                                                                   
 29 }
 执行结果
 root@instance-u1n6fu49:~/linux/nonblock_io# ./main 
read error:11   Resource temporarily unavailable
read error:11   Resource temporarily unavailable
read error:11   Resource temporarily unavailable
read error:11   Resource temporarily unavailable
read error:11   Resource temporarily unavailable
^C

i/o多路复用
为什么需要多路复用 在一个进程或者线程中同时从多个描述符读取数据时，我们不能在任意一个描述符上进行阻塞读,否则可能会因为被阻塞在其中一个描述符上而导致另外的描述符即使有数据
也无法处理

什么叫轮询
  对第一个描述符发一个read如果该输入上有数据，则读数据并处理他，如果无数据可读，则该调用立即返回，然后对下一个描述符做同样的处理。在此以后等待一定的时间，然后再次从头开始，这种方式就称为轮询
  轮询虽然简单，但是浪费了大量的cpu时间,大多数时间这些套接字都是属于无数据可读，因此执行read系统调用浪费了时间

异步i/o
  进程告诉内核，当描述符准备好可以进行i/o时，用一个信号通知他
  但是异步i/o潜在问题如下
  1) 只有当描述符引用网络或者终端设备等流设备时信号才起作用(sigpoll/sigio)
  2) 就算是产生了信号也无法知道是哪个描述符有数据可读,并且现有的信号数量远小于潜在的打开文件描述符数量,为了确定是哪一个描述符准备好了，任需要将描述符设置为非阻塞i/o
    ，并顺序尝试执行i/o
  
i/o多路转接(i/o多路复用)
  先构造一张我们感兴趣的描述符的列表,然后调用一个函数,直到描述符的一个已准备好进行i/o时,该函数才返回

select和select
  #include<sys/select.h>
  int select( int maxfdpl, fd_set * restrict readfds, fd_set* restrict writefds, fd_set* restrict execptfds,
             struct timeval* restrict tvptr );
  参数 tvptr 指定愿意等待的时间长度
  1) tvptr == NULL 无限等待，如果收到一个信号则中断此无限期等待, 如果捕捉到一个信号,则select 返回-1 errno 设置为EINTR
  2) tvptr->tv_sec == 0 && tvptr_tv_usec == 0 根本不等待，测试所有指定描述符并立即返回。这是轮询系统找到多个描述符状态而不阻塞select函数的方法( 即改为轮询 )
  3) tvptr->tv_sec != 0 || tvptr->tv_usec != 0 等待指定的的描述和微妙数，当有指定的描述符之一已准备好，或当指定的时间已经超过时立即返回。如果在超时到期还没有一个描述符准备好
    则返回0，这种等待可被捕捉到的信号中断
  参数 readfds, writefds, exceptfds 是指向描述符集合的指针 有可读的放入readfds中 有可写的描述符放入writefds 有出错的放入exceptfds中
  int fd_isset( int fd, fd_set* fdset ); 如果返回0 则表明不在描述符集合中 否则表明在描述符集合中
  void FD_CLR( int fd, fd_set* fdset ); 将描述符从描述符集合中清除
  void FD_SET( int fd, fd_set* fdset ); 将这个描述符添加到描述符集合中去
  void FD_ZERO( fd_set* fdset ); 将这个描述符集合置0
  并这三个参数 任意一个可以置为NULL表明不关心对应的条件
  
  maxfd 最大文件描述符编号值加1、也可以设置为FD_SETSIZE 这是sys/select.h中的一个常量，它指定最大描述符，通常内核就在此范围内寻找打开的位
  比如maxfd=10 那只会去找0-10 而不会去找10以后的fd
  
  所以描述符集合底层就是一个大小为maxfd+1的数组
  
  select 返回值
  1) -1表示出错，这是有可能发生的
  2) 0表示没有描述符准备好，比如超时了都还没有描述符准备好那么三个描述符集合都置为0
  3) 一个正值说明了已经准备好读和写，如果同一个描述符已准备好读和写，那么在返回值中会对其计数两次 读和写中对应的位置为1
  
  
             



