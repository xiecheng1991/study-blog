进程标识(pid)
  进程标识是一个非负整数 用来标识一个唯一的进程,但是进程标识可复用,当一个进程终止以后其进程ID可以拿去标识其他进程
  大多数unix都采用延迟复用技术 这是为了避免 系统还在认为使用的是之前的进程而不是新进程

0号进程和1号进程以及2号进程
  0号进程是系统进程该进程是内核进程通常被称为交换进程，它并不会执行任何磁盘上的程序
  1号进程 init进程 在自举过程结束后由系统调用而产生的一个用户进程，但是它以超级用户特权运行 通常用于读取配置完成系统的初始化工作 启动一个unix系统
        init进程绝不会终止,因为它会成为所有孤儿进程的父进程
  所以实际上unix进程是一个树形结构
                   0号进程
                      |
                    1进程
  
  2号进程 页守护进程 此进程负责支持虚拟存储器系统的分页操作

fork 创建进程
  pid_t fork(void);
  该函数返回两次 因为父进程执行fork函数后面指令
  子进程返回0 这里的0不是代表进程号 那是因为0号进程是系统进程 并且每个进程有且只有一个唯一的父进程
  父进程返回子进程ID 那是因为一个父进程可以有多个子进程 所以才返回了进程ID
  
  fork了以后 子进程拷贝了父进程的内存空间 数据段(初始化和未初始化数据段(bss)) 堆区 栈区 但是他们共享正文段
  
  由于fork了以后 跟着exec执行程序 所以现在很多实现并不执行一个父进程的内存空间副本 而是采用写时复制技术 这些区域有父子进程共享
  并且内核将他们的访问权限改变为只读，如果父进程或者子进程视图修改这些区域，则内核只为修改区域的那块内存制作一个副本 通常是虚拟内存中的一个页
  简单总结 写时复制 就是说 子进程不再拷贝父进程的内存空间 反而和父进程共享一块区域 这个区域只读 只有在父子进程尝试修改时 内核就把这个区域进行一个拷贝 通常情况下是用了一个内存页
  为什么要共享内存区域?
    那是因为fork以后 操作系统要为子进程分配内存区域 并且拷贝父进程的内存区域
    但是通过写时复制 可以避免大量的拷贝  比如只有当子进程修改了那个内存区域过后  才用一个内存页来拷贝这些被改动过后的内存 然后让子进程引用到这个新的内存页
  
  
  
  
