线程的定义:
  在单进程环境中执行多个任务，一个进程中的所有线程都可以访问该进程的组件部分，比如文件描述符和内存
  
线程数据:
  每个线程都包含有表示执行环境所必须的信息
    1) 线程id 用来标识一个唯一的线程
    2) 一组寄存器值(用来保存线程的执行状态) 所以在多线程环境下有些全局值 要用volatile关键字标识 每次都从内存中取 而不是直接取寄存器中的值
      因为编译器优化 取寄存器中的值 的确比取内存中的值快得多
    3) 栈(存放局部变量)
    4) 调度优先级
    5) 策略
    6）信号屏蔽字
    7) errno变量
    8) 线程私有数据( skynet框架中用标识是工作线程还是主线程 )
    
可以通过#ifdef _POSIX_THREADS 是否有定义 _POSIX_THREADS宏 从而在编译时期确定是否支持线程

线程的创建
#include<pthread.h>
int pthread_create( pthread_t * restrict tidp, const pthread_attr_t * restrict attr, void* ( *start_rtn )( void* ), void* restrict arg );
若成功返回0 否则 返回错误编号
若果返回成功
1) 子线程的线程id 被放置在tidp所指向的内存空间中
2) attr为线程属性 一般情况下传入NULL
3) start_rtn为线程入口函数
4) arg 为传递给线程的参数

线程的终止
  1) 从启动例程中返回
  2） 线程可以被同一进程中的其他线程取消
  3) 线程调用pthread_exit
#include<pthread.h>
void pthread_exit( void* rval_ptr )
rval_ptr是一个无类型指针，与传递给线程启动例程的参数类似进程中的其他线程也可以通过pthread_join函数访问到这个指针

#include<pthread.h>
int pthread_join(pthread_t thread, void**rval_ptr);
若成功返回0 否则返回错误编号
调用线程将一直阻塞，直到指定的线程调用pthread_exit,从启动例程中返回，或者被取消
如果是简单返回rval_ptr就包含返回码
如果线程被取消 rval_ptr所指向的内存区域就被设置成PTHREAD_CANCELED

线程的取消
#include<pthread.h>
int pthread_cancel(pthread_t tid); 取消线程id为tid的线程
调用pthread_cancel函数会使得由tid标识的线程行为表现如同调用了参数为PTHREAD_CANCLE的pthread_exit函数
但是线程可以选择忽略或者取消或者控制如何被取消
注意:pthread_cancle并不等待线程终止 仅仅是发出请求

线程可以安排它退出时需要调用的函数 这样的线程被称为线程清理处理程序一个线程可以建立多个清理处理程序。处理程序记录在栈中，也就是说他们的执行顺序和他们的注册顺序是相反的

#include<pthread.h>
void pthread_cleanup_push( void(*rtn)(void *), void* arg );
void pthread_cleanup_pop(int execute);

pthread_cleanup_pop和pthread_cleanup_push调用要匹配起来,否则编译可能通不过


