信号的概念
  信号是软件中断,信号提供了一种处理异步事件的方法
  信号都是以SIG开头
  SIGABRT是夭折信号 进程调用abort()函数时产生的信号
  SIGALRM是闹钟信号 调用alarm函数设置的定时器超时后产生此信号
头文件
  #include<signal.h>
信号都被定义为正整数常量(信号编号)

不存在编号为0的信号, kill函数对信号编号0有特殊应用,POSIX将此种信号编号值称为空信号

很多条件可以产生信号
1) 中断信号 在终端上按Delete或者Ctrl+C通常产生中断信号(SIGINT), 这是停止一个已失去控制程序的方法
2) 硬件异常产生信号: 除数为0,无效的内存引用，这些条件通常由硬件检测到,并通知内核。然后内核为该条件发生时正在运行的进程产生适当的信号
3) 进程调用kill(2) 函数可以将任意信号发送给另一进程组或者另一进程
  限制条件为接收信号进程和发送信号进程的所有者必须相同 或者发送信号的进程所有者必须是超级用户
4) 用户可以用kill(1) 命令将信号发送给其他进程, 此命令是kill函数的接口。常用此命令终止一个失控的后台进程
5) 当检测到某种软件条件已经发生，并应将其通知有关进程时也产生信号
  例如SIGURG(网络连接上传来的带外数据), SIGPIPE(管道的读进程已经终止,一个进程写此管道)以及SIGARLM(进程所设置的定时器已经超时)

信号是异步事件的经典实例

在某个信号出现时,可以告诉内核按下列三种方式之一进行处理
  1) 忽略该信号
      大多数信号都可以使用这种方式进行处理,但是有两种信号却决不能被忽略。他们是SIGKILL和SIGSTOP 这两个是用来关闭失控的程序或者后台进程
  2) 捕捉信号
      为了做到这一点 要向内核注册一个信号处理函数,在这个处理函数中可执行用户希望对这个信号进行的处理
      注意不能捕捉SIGKILL和SIGSTOP信号
  3) 执行系统默认动作
      注意大多数系统的默认动作就是终止该进程

--------------------------------------------------从信号的产生到信号处理程序的调用之间有一定的间隔 所以很容易产生不可靠信号-------------------------------------------------------------
  
函数signal()
  void ( *signal( int signo, void( *func )( int ) ) )( int );
  分析 signal函数 参数int signo, 和一个返回值为void 参数为int的函数指针 
    signal函数返回了一个 返回值为void 参数为int的函数指针 就是返回了上一个信号处理函数
  参数信息
  1) signo参数是信号名
  2） func的值 
      2.1)通常是SIG_IGN(忽略)
      2.2)SIG_DFL( 默认处理 )
      2.3)当指定函数地址时，则当信号发生就会调用该函数,称这种方式为捕捉该信号,此函数称为信号处理程序或者信号捕捉函数
 返回值 上一个信号处理函数的指针
 
 用后台方式启动程序
 ./main &
 
 可以通过kill 命令向程序发送信号
 例如 kill -USR1 pid 向pid发送USR1信号
 
 信号与子进程
    子进程调用exec函数将原先设置为要捕捉的信号都更改为默认动作，其他处理不变
    因为新的进程空间信号处理函数都已经不在了
    但是如果没有使用exec函数时 子进程继承父进程的信号处理
    
程序启动
    当执行一个程序时,所有信号的状态都是系统默认或者忽略的，通常所有信号都被设置为它们的默认动作，除非调用exec的进程忽略该信号,确切的将
    exec函数将原先要设置为要捕捉的信号都更改为默认动作，其他信号状态不变， 因为新的进程空间信号处理函数都已经不在了，所以再捕捉也没什么意义了
  一个具体例子是一个交互shell自动将一个后台进程对中断和退出的处理方式设置为忽略。于是当按下中断字符时就不会影响到后台进程。
  
进程创建
    当一个进程调用fork时，其子进程继承父进程的信号处理方式。因为子进程在开始时复制了父进程的内存映像，所以信号捕捉函数的地址在子进程中也是有意义的
    
不可靠信号
    早期版本的处理方式的一个问题是在进程每次接收到信号对其进行处理时， 随即将该信号动作重置为默认值,这就造成了书中很多例子在讲解不可靠信号处理时
    在处理函数中会立即再进行一次signal函数调用注册对应信号的处理程序
    不可靠在这里指的是，信号可能会丢失
    如下例子
      1 //不可靠信号
  2                            
  3 #include<stdio.h>          
  4 #include<stdlib.h>
  5 #include<unistd.h>
  6 #include<signal.h>
  7 
  8 static void sig_int();
  9 static int sig_int_flag;
 10 
 11 int
 12 main( int argc, char* argv[] ) {
 13     signal( SIGINT, sig_int );
 14     while( sig_int_flag == 0 ) {    
 15         //此时发生了SIGINT信号 就算将sig_int_flag置为了1 都不能阻止睡眠
 16         //如果后面不再产生sigint信号 则会导致永久阻塞
 17         pause();
 18     }
 19     return 0;
 20 }
 21 
 22 void
 23 sig_int() {
 24     signal( SIGINT, sig_int );
 25     sig_int_flag = 1;
 26 }
 
中断系统的调用
  如果进程正在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错。其errno设置为EINTER
  这样处理的原因是因为一个信号发生了，进程捕捉到它。这意味着已经发生了某种事情，所以应该唤醒阻塞的系统调用。
  被中断的是内核中执行的系统调用
  低速系统调用:   是可能会使进程永远阻塞的系统调用
    1) 如果某些类型文件(如读管道，终端设备和网络设备)的数据不存在时 则读操作可能会使调用者永远阻塞
    2) 如果这些数据不能被相同类型的文件立即接受 则写操作可能会使调用者永远阻塞
    3) 在某种条件发生之前打开某些类型文件,可能会发生阻塞（例如打开一个终端设备，需要先等待与之连接的调制解调器的应答）
    4) pause函数(按照定义，它使调用进程阻塞直到捕捉到一个信号)和wait函数类似
    5) 某些ioctl函数
    6) 某些进程间的通信函数
  需要特别注意的是磁盘i/o有关的系统调用。虽然磁盘i/o会阻塞调用者 但是i/o操作总是很快返回,并使调用者不再处于阻塞状态
  
可重入函数
  进程捕捉到信号并对其进行处理时, 进程正在执行的正常指令序列就被信号中断程序临时中断，它首先执行该信号处理程序中的指令,如果从信号处理程序返回,则继续执行在捕捉信号时进程正在执行的正常指令序列
  
  *********malloc的执行
    malloc通常会为它所分配的存储区维护一个链表
    
SIGCLD语义
  BSD采用的是SIGCHLD信号
  当子进程状态改变以后产生此信号,父进程需要调用一个wait函数以检测发生了什么。
  对于该信号的处理方式如下
  1) 如果该进程明确的将该信号的配置设置为SIG_IGN忽略 那么就是该进程的子进程终止时就不管最后这些终止了的子进程直接由1号进程进行处理
  2) 如果将SIGCLD的配置设置为捕捉，则内核立即检查是否有子进程准备好被等待,如果是，则立即调用SIGCLD处理程序
 
kill和rase
  kill 将信号发送给进程或者进程组
  raise则允许进程向自身发送信号
  #include<signal.h>
  int kill( pid_t pid, int signo );
   pid参数:
   1) > 0将信号发送给进程ID为pid的进程
   2) == 0 发送给进程所属的进程组下的所有进程
   3) < 0 将信号发送给其进程组ID等于pid绝对值的，而且具有发送权限的所有进程.
   4) == -1 将该信号发送给发送进程有权限的向他们发送信号的所有进程
   信号编号为0的信号为空信号kill只是正常的执行错误检查 并不发送信号,这通常被用来确定一个特定的进程是否存在如果不存在返回-1 errno被设置为ESRCH
  
  int raise( int signo );
  
 alarm和pause
  #include<unistd.h>
  unsigned int alarm( unsigned int seconds );
  参数seconds的值是产生信号sigalarm需要经过的时钟秒数。当这一时刻到达时,信号由内核产生，由于进程调度的延迟，所以从信号的产生到进程的处理还需要一个时间间隔。
  alarm(10) a
  alarm(5) b
  alarm(0) c
  b调用之前还有啊未超时则用b的5替换掉a的10
  如果b还未超时 调用c则取消闹钟
  
  pause函数使进程挂起直到捕捉到一个信号
  只有当一个信号被捕捉并且从对应信号的处理程序返回 这个pause函数才会返回

sigprocmask 检测或更改 或同时检测和更改进程的信号屏蔽字
  sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);
  1) oset是非空指针,那么进程的当前信号屏蔽字通过oset返回
  2) set是一个非空指针,则参数how指示如何修改当前信号屏蔽字
    2.1） how为SIG_BLOCK 该进程新的屏蔽字是当前信号屏蔽字和set指向信号集的并集。(信号sigset_t set中新增)
    2.2） how为SIG_UNBLOCK 则该进程新的屏蔽字是当前信号屏蔽字和set指向的信号集补集的交集
    2.3)  how为SIG_SETMASK 则该进程屏蔽set指向的值
  但是不能屏蔽SIGKILL和SIGSTOP信号
  3) 如果set是个空指针，则不改变

  
  
