信号的概念
  信号是软件中断,信号提供了一种处理异步事件的方法
  信号都是以SIG开头
  SIGABRT是夭折信号 进程调用abort()函数时产生的信号
  SIGALRM是闹钟信号 调用alarm函数设置的定时器超时后产生此信号
头文件
  #include<signal.h>
信号都被定义为正整数常量(信号编号)

不存在编号为0的信号, kill函数对信号编号0有特殊应用,POSIX将此种信号编号值称为空信号

很多条件可以产生信号
1) 中断信号 在终端上按Delete或者Ctrl+C通常产生中断信号(SIGINT), 这是停止一个已失去控制程序的方法
2) 硬件异常产生信号: 除数为0,无效的内存引用，这些条件通常由硬件检测到,并通知内核。然后内核为该条件发生时正在运行的进程产生适当的信号
3) 进程调用kill(2) 函数可以将任意信号发送给另一进程组或者另一进程
  限制条件为接收信号进程和发送信号进程的所有者必须相同 或者发送信号的进程所有者必须是超级用户
4) 用户可以用kill(1) 命令将信号发送给其他进程, 此命令是kill函数的接口。常用此命令终止一个失控的后台进程
5) 当检测到某种软件条件已经发生，并应将其通知有关进程时也产生信号
  例如SIGURG(网络连接上传来的带外数据), SIGPIPE(管道的读进程已经终止,一个进程写此管道)以及SIGARLM(进程所设置的定时器已经超时)

信号是异步事件的经典实例

在某个信号出现时,可以告诉内核按下列三种方式之一进行处理
  1) 忽略该信号
      大多数信号都可以使用这种方式进行处理,但是有两种信号却决不能被忽略。他们是SIGKILL和SIGSTOP 这两个是用来关闭失控的程序或者后台进程
  2) 捕捉信号
      为了做到这一点 要向内核注册一个信号处理函数,在这个处理函数中可执行用户希望对这个信号进行的处理
      注意不能捕捉SIGKILL和SIGSTOP信号
  3) 执行系统默认动作
      注意大多数系统的默认动作就是终止该进程
  
函数signal()
  void ( *signal( int signo, void( *func )( int ) ) )( int );
  分析 signal函数 参数int signo, 和一个返回值为void 参数为int的函数指针 
    signal函数返回了一个 返回值为void 参数为int的函数指针 就是返回了上一个信号处理函数
  参数信息
  1) signo参数是信号名
  2） func的值 
      2.1)通常是SIG_IGN(忽略)
      2.2)SIG_DFL( 默认处理 )
      2.3)当指定函数地址时，则当信号发生就会调用该函数,称这种方式为捕捉该信号,此函数称为信号处理程序或者信号捕捉函数
 返回值 上一个信号处理函数的指针
 
 用后台方式启动程序
 ./main &
 
 可以通过kill 命令向程序发送信号
 例如 kill -USR1 pid 向pid发送USR1信号
 
 信号与子进程
    子进程调用exec函数将原先设置为要捕捉的信号都更改为默认动作，其他处理不变
    因为新的进程空间信号处理函数都已经不在了
    但是如果没有使用exec函数时 子进程继承父进程的信号处理
    
程序启动
    当执行一个程序时,所有信号的状态都是系统默认或者忽略的，通常所有信号都被设置为它们的默认动作，除非调用exec的进程忽略该信号,确切的将
    exec函数将原先要设置为要捕捉的信号都更改为默认动作，其他信号状态不变， 因为新的进程空间信号处理函数都已经不在了，所以再捕捉也没什么意义了
  一个具体例子是一个交互shell自动将一个后台进程对中断和退出的处理方式设置为忽略。于是当按下中断字符时就不会影响到后台进程。
  
进程创建
    当一个进程调用fork时，其子进程继承父进程的信号处理方式。因为子进程在开始时复制了父进程的内存映像，所以信号捕捉函数的地址在子进程中也是有意义的
    
不可靠信号
    不可靠在这里指的是，信号可能会丢失
    如下例子
      1 //不可靠信号
  2                            
  3 #include<stdio.h>          
  4 #include<stdlib.h>
  5 #include<unistd.h>
  6 #include<signal.h>
  7 
  8 static void sig_int();
  9 static int sig_int_flag;
 10 
 11 int
 12 main( int argc, char* argv[] ) {
 13     signal( SIGINT, sig_int );
 14     while( sig_int_flag == 0 ) {    
 15         //此时发生了SIGINT信号 就算将sig_int_flag置为了1 都不能阻止睡眠
 16         //如果后面不再产生sigint信号 则会导致永久阻塞
 17         pause();
 18     }
 19     return 0;
 20 }
 21 
 22 void
 23 sig_int() {
 24     signal( SIGINT, sig_int );
 25     sig_int_flag = 1;
 26 }
 
中断系统的调用
  如果进程正在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错。其errno设置为EINTER
  这样处理的原因是因为一个信号发生了，进程捕捉到它。这意味着已经发生了某种事情，所以应该唤醒阻塞的系统调用。
  被中断的是内核中执行的系统调用
  低速系统调用:   是可能会使进程永远阻塞的系统调用
    1) 如果某些类型文件(如读管道，终端设备和网络设备)的数据不存在时 则读操作可能会使调用者永远阻塞
    2) 如果这些数据不能被相同类型的文件立即接受 则写操作可能会使调用者永远阻塞
    3) 在某种条件发生之前打开某些类型文件,可能会发生阻塞（例如打开一个终端设备，需要先等待与之连接的调制解调器的应答）
    4) pause函数(按照定义，它使调用进程阻塞直到捕捉到一个信号)和wait函数类似
    5) 某些ioctl函数
    6) 某些进程间的通信函数
