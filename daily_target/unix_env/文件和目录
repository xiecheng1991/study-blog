函数stat fstat fstatat和lstat
####可以做一个练习题客户端给一个目录或文件 服务器返回该文件如果是目录则还要返回该目录下的文件
#include<sys/stat.h>
1) int stat( const char* restrict pathname, struct stat* restrict buf );
    一旦给出pathname, stat函数将返回与此命名文件有关的信息结构。
2) int fstat( int fd, struct stat* restrict buf );
    fstat函数获得已在描述符fd上打开文件有关信息
3) int lstat( const char* restrict pathname, struct stat* restrict buf );
    lstat函数返回该符号链接的有关信息，而不是该符号链接引用的文件的信息
4) int fstatat( int fd, const char* restrict pathname, struct stat* restrict buf, int flag );
    


文件类型
  1)  普通文件
  2) 目录文件
    这种文件包含了其他文件的名字和指向这些文件的有关信息的指针
  3) 块特殊文件
    这种类型的文件提供对设备如磁盘带缓冲的访问,每次访问以固定的长度为单位进行
  4) 字符特殊文件
    这种类型的文件提供对设备不带缓冲的访问,每次访问长度可变
  5) FIFO
    命名管道文件 用于进程间的通信
  6) 套接字
      这种类型的文件用于进程间的网络间通信 也可以用于进程间的非网络通信
  7) 符号连接
     这种类型的文件 指向另外一个文件
  文件类型信息包含在stat结构中的st_mode成员中。可以用如下宏确定文件类型,这些宏的参数都是stat结构中的st_mode成员
     S_ISREG()    普通文件
     S_ISDIR()    目录文件
     S_ISCHR()    字符特殊文件
     S_ISBLK()    块特殊文件
     S_ISFIFO()   管道或者FIFO
     S_ISLNK()    符号链接
     S_ISSOCK()   套接字
设置用户ID和组ID
    与一个文件相关的ID有六个或更多
       1) 实际用户ID
       2) 实际组ID
       以上两个表明实际上我们是谁
       
       3) 有效用户ID
       4) 有效组ID
       5) 附属组ID
       用于文件访问权限检查
       
       6) 保存的设置用户ID
       7) 保存的设置组ID
       由exec函数报错
       
     每个文件都有一个所有者和组所有者
     所有者 stat结构中的st_uid指定
     组所有者 stat结构中的st_gid指定
文件访问权限
    stat结构中的st_mode值也包含了对文件的访问权限,所有文件类型都有访问权限
    9个访问权限位
    S_IRUSR     用户读
    S_IWUSR     用户写
    S_IXUSR     用户执行
    
    S_IRGRP     组读
    S_IWGRP     组写
    S_IXGR      组执行
    
    S_IROTH     其他读
    S_IWOTH     其他写
    S_IXOTH     其他执行
    
 chmod命令可以修改这9个权限位 u表示用户 g表示组 o表示其他
 
 新文件和目录所有权
    新文件的用户ID设置为进程的有效用户ID
    关于组ID则可能有如下两种情况
    1) 新文件的组ID 可以是进程有效组ID
    2) 新文件的组ID 可以是它所在目录的组ID
    
  函数access和faccess
    #include<unistd.h>
    int access( const char* pathname, int mode );
    int faccess( int fd, const char* pathname, int mode, int flag );
    两个函数的返回值;若成功返回0 若出错返回-1
    如果测试文件是否已经存在,mode就为F_OK 否则mode就为如下所列常量的按位与
    R_OK 测试读权限
    W_OK 测试写权限
    X_OK 测试执行权限
    
  函数umask
    进程相关联的文件模式屏蔽字,并返回之前的值
    #include<sys/stat.h>
    mode_t umask( mode_t cmask );
    其中cmask是由上面9个与文件相关联的权限位通过或运算构建出来的
    通过例子可以得出 屏蔽掉通过该程序的权限为 如果umask(0)表示不屏蔽
   #include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<errno.h>
#include<string.h>

//文件所有者 可读写
//文件所属组 可读写
//其他人 可读写
#define RWRWRW (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)

int
main( int argc, char* argv[] ) { 
    umask(0);
    if ( creat( "foo", RWRWRW ) == -1 ) { 
        printf( "create foo error:%s\n", strerror( errno ) );
        return -1; 
    }   

    umask( S_IRGRP|S_IWGRP|S_IWOTH|S_IROTH );
    if ( creat( "bar", RWRWRW ) == -1 ) { 
        printf( "create bar error:%s\n", strerror( errno ) );
        return -1; 
    }   

    return 0;
}
root@instance-u1n6fu49:~/linux/unix_env/director_file# ls -l bar
-rw------- 1 root root 0 Mar  9 15:57 bar 所以bar文件就只能文件所有者可读写

root@instance-u1n6fu49:~/linux/unix_env/director_file# ls -l foo
-rw-rw-rw- 1 root root 0 Mar  9 15:57 foo 所以foo文件 文件所有者 所属组和其他人都可读写

文件长度
    stat结构成员st_size表示以字节为单位的文件的长度。此字段只针对普通文件,目录和符号有用
    1) 对于普通文件，其文件长度可以是0, 在开始读取这种文件时, 将得到文件结束标志
    2) 对于目录,文件长度通常是一个数(16或者512)的整数倍
    3) 符号链接, 文件长度是在文件名中的实际字节数 并且它并不包含通常c语言用作名字结尾的null字节
    st_blksize和st_blocks 其中第一个是对文件i/o较合适的块长度,第二个是所分配的实际512字节块块数。3.9节提到了当将st_blksize用于读操作时，读一个文件所需时间量最少。
    
    文件空洞
        引起文件空洞问题的原因在于所设置的偏移量超过文件尾端，并写入某些数据后造成的
        思考了一下用流 也会出现同样的情况
      1 //文件空洞
  2 #include<stdio.h>          
  3 #include<stdlib.h>         
  4 #include<unistd.h>
  5 #include<fcntl.h>          
  6 #include<errno.h>          
  7 #include<string.h>         
  8 
  9 int
 10 main( int argc, char* argv[] ) {
 11                            
 12     int fd = open( "test", O_CREAT|O_RDWR ); 
 13     if ( fd == -1 ) {      
 14         printf( "open test error:%s\n", strerror( errno ) );
 15         return -1;
 16     }
 17 
 18     if ( lseek( fd, 10, SEEK_END ) == -1 ) {
 19         printf( "lseek error:%s\n", strerror( errno ) );
 20         return -1;
 21     }
 22 
 23     if ( write( fd, "hello world", 12 ) == -1 ) {
 24         printf( "write error:%s\n", strerror( errno ) );
 25         return -1;
 26     }
 27 
 28     return 0;
 29 }
