流和file对象
  当使用标准i/o库打开或创建一个文件时,我们已使一个流与一个文件相关联
流的定向
  决定了所读写的字符是单字节还是多字节的。当一个流最初被创建时,它并没有被定向
    1) 如果使用的是多字节的i/o函数,则将该流的定向设置为宽定向的(wchar.h)
    2) 如果使用的是一个单字节i/o函数,则将该流的定向设置为字节定向
  freopen清除流的定向,fwide函数设置流的定向
 
 #include<stdio.h>
 #include<wchar.h>
 int fwide( FILE* fp, int mode );
 返回值: 若流是宽定向的, 返回正值, 若流是字节定向的,返回负值;若流是未定向的,返回0
 根据mode参数的不同值, fwrite的函数执行不同的工作。
    1) 如若mode参数为负 fwide将试图指定的流是字节定向的
    2) 如若mode参数为正 fwide将试图指定流是宽(多字节)定向
    3) 如若mode参数为0  fwide将不试图设置流的定向,但返回标识该流定向的值
 注意: fwide不能改变已定向的流的定向(也就是说必须是未定向过的) 并且fwide没有出错返回,唯一可以依靠的是在出错前先清除errno, 从fwide返回时检查errno的值

当打开一个流时,标准i/o函数fopen返回一个指向FILE对象的指针.对象通常是一个结构 包含了很多信息 详情参考后面的知识

标准输入, 标准输出和标准错误
  操作系统为每一个进程预定义了3个流 并且这个3个流可以自动的被进程所使用,他们分别是STDIN_FILENO标准输入 STDOUT_FILENO标准输出 STDERR_FILENO标准出错所引用,
  预定义的三个文件指针stdin, stdout, stderr 定义在<stdio.h>中
  
缓冲
  缓冲的目的 通过malloc分配一定的内存空间 缓存数据 避免频繁的write和read执行i/o
  缓冲的类型
    1) 全缓冲
        只有当缓冲区已满时 才执行实际i/o操作
    2) 行缓冲
        当流涉及到一个终端时(如标准输入和标准输出)，通常使用行缓冲
        1) 遇到换行符 执行i/o
        2) 缓冲区已满 执行i/o
       行缓冲限制
          1) 因为标准库用来收集每一行的缓冲区长度是固定的,所以只要填满了缓冲区就会执行i/o
          2) 如果要通过标准i/o库要从一个不带缓冲的流或者一个行缓冲的流得到输入数据,那么它就会冲洗所有行缓冲输出流
            猜测原因 大概是避免数据不及时 不能读取到最新的数据,而且从一个不带缓冲的流或者一个行缓冲的流中就可以说明是从设备(书中说的是内核)中读取,所以必须要先刷新行输出流
    3) 不带缓冲
        标准出错一般不带缓冲 是为了让错误信息更加及时
        直接调用read和write
  fflush清洗缓冲区 将缓冲区的内容写入到文件中
  
  对于一个给定的流,如果我们并不喜欢这些系统默认,则可以调用下列两个函数中的一个更改缓冲类型
      #include<stdio.h>
      void setbuf( FILE *restrict fp, char* restrict buf );
        1) 关闭流的缓冲 可以将buf设置为NULL
        2) 如果要增加缓冲 buf必须指向一块长度为BUFFSIZE的缓冲区(该常量定义在<stdio.h>中),并且通常在此设置过后就变成了全缓冲
      int setvbuf( FILE* restrict fp, char* restrict buf, int mode, size_t size );
         功能与setbuf类似 不过可以通过mode参数指定缓冲类型
         1) _IOFBF  全缓冲
         2) _IOLBF  行缓冲
         3) _IONBF  不带缓冲 如果指定为不带缓冲的流,则忽略buf和size参数
      返回值 若成功,返回0 若出错 返回非0
      注意事项 这些函数一定要在流已被打开后使用
